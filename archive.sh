#!/bin/bash
#
# Script to archive an existing xcode project to a target location.
# The script checks for a post-build action that defines the $ARCHIVE_PATH as follows:
# echo "ARCHIVE_PATH=\"$ARCHIVE_PATH\"" > $PROJECT_DIR/archive_paths.sh
# If such post-build action does not exist or sourcing it doesn't define the $ARCHIVE_PATH variable, 
# the script tries to generate it programmatically by finding the latest build in the expected archiving folder
#
# author: Andrea Bizzotto
# email: bizz84@gmail.com
#

post_build_script=archive_paths.sh
OUTPUT=output/
XCODEBUILD_CMD='/Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild'
TARGET_SDK=iphoneos
XCODE_CONFIG=Production
PROJECT_NAME=ArchiveTest.xcodeproj
# Provisioning profile and signing stuff
# These variables will be overridden by the command line arguments if supplied
DEFAULT_PROFILE_NAME=ArchiveTest
PROVISIONING_PROFILE="/Users/$USER/Library/MobileDevice/Provisioning Profiles/$DEFAULT_PROFILE_NAME.mobileprovision"
SIGN_PROVISIONING_PROFILE=$(cat "$PROVISIONING_PROFILE" | egrep  -a  -o '[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}')

function archive()
{
    echo "Archiving target '$1'"

    # Delete $post_build_script if it already exists as it should be generated by a post-build action
    rm -f $post_build_script

    ${XCODEBUILD_CMD} clean archive -workspace $PROJECT_NAME/project.xcworkspace -scheme $1 -sdk "${TARGET_SDK}" -configuration "$XCODE_CONFIG" "CODE_SIGN_IDENTITY=$3" "PROVISIONING_PROFILE=$2"

    if [ $? != 0 ]
    then
        echo "Failed to make the build"
        exit 1
    fi

    # Check if archive_paths.sh exists
    if [ -f "$post_build_script" ]; then
        source "$post_build_script"
	if [ -z "$ARCHIVE_PATH" ]; then
	    echo "'$post_build_script' exists but ARCHIVE_PATH was not set. Enabling auto-detection" 
	fi
    fi
    if [ -z "$ARCHIVE_PATH" ]; then
        # This is the format of the xcarchive path:
        # /Users/$USER/Library/Developer/Xcode/Archives/`date +%Y-%m-%d`/$1\ `date +%d-%m-%Y\ %H.%M`.xcarchive
        # In order to avoid mismatches with the hour/minute of creation of the archive and the current time, we list all archives with
        # the correct target that have been built in the current day (this may fail if the build wraps around midnight) and
        # fetch the correct file with a combination of ls and grep.
        # This script can break only if there are multiple targets with exactly the same name running at the same time.
        EXTRACTED_LINE=$(ls -lrt /Users/$USER/Library/Developer/Xcode/Archives/`date +%Y-%m-%d`/ | grep $1\ `date +%d-%m-%Y` | tail -n 1)
        if [ "$EXTRACTED_LINE" == "" ]; then
            echo "Error: couldn't fetch archive path"
            exit 1
        fi
        # ls -lrt prints lines with the following format
        # drwxr-xr-x  5 mario  1306712193  170 25 Jul 17:17 ArchiveTest 25-07-2013 17.17.xcarchive
        # We can split this line with the " " separator and take the latest bit: 17.17.xcarchive
        FILE_NAME_SUFFIX=$(echo $EXTRACTED_LINE | awk '{split($0,a," "); print a[11]}')
        if [ "$FILE_NAME_SUFFIX" == "" ]; then
            echo "Error: couldn't fetch archive path"
            exit 1
        fi
        # Finally, we can put everything together to generate the path to the xcarchive
        ARCHIVE_PATH="/Users/$USER/Library/Developer/Xcode/Archives/`date +%Y-%m-%d`/$1 `date +%d-%m-%Y` $FILE_NAME_SUFFIX/"
    fi

    # Create output folder if it doesn't already exist
    mkdir -p "$OUTPUT"

    # Move archived xcarchive build to designated output folder
    mv -v "$ARCHIVE_PATH" "$OUTPUT"
}



# Check number of command line args
if [ $# -lt 1 ]; then
    echo "Syntax: `basename $0` <target name> [<provisioning profile>] [<code sign identity]"
    exit 1
fi

if [ ! -z "$2" ]; then
    PROVISIONING_PROFILE="$2"
fi

if [ ! -z "$3" ]; then
    SIGN_PROVISIONING_PROFILE="$3"
fi

archive "$1" "$PROVISIONING_PROFILE" "$SIGN_PROVISIONING_PROFILE"

